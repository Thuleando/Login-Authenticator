-- Generated by Oracle SQL Developer Data Modeler 4.0.2.840
--   at:        2014-11-11 22:05:41 MST
--   site:      Oracle Database 11g
--   type:      Oracle Database 11g




CREATE TABLE Accounts
  (
    --  Although Username must be unique, it can be changed. This ID doesn't
    --  change. Having this unchangeable ID allows the username to be changed with
    --  fewer other changes having to be propagated through the database as a
    --  result of that one change.
    ID          NUMBER (10) NOT NULL ,
    Username    VARCHAR2 (16) NOT NULL ,
    PWord       VARCHAR2 (16) NOT NULL ,
    WhenCreated TIMESTAMP (4) NOT NULL ,
    --  Most recent date that the account was unlocked. For new accounts, it should
    --  be set to the same date as WhenCreated.
    --  This is to deal with scenarios when an administrator has unlocked an
    --  account upon the user's request, in the same calendar day that the user
    --  locked themselves out (with too many failed login attempts). In such an
    --  event, the user would again lock themselves out if they have a failed login
    --  attempt even once in that same day!
    --  With this column, the 3 failed login attempts must all occur after the
    --  UnlockDate (in addition to being on the same calendar day) in order to
    --  cause a lockout.
    UnlockDate TIMESTAMP (4) NOT NULL ,
    --  If NULL, the account is unlocked. Otherwise, the value is the timestamp
    --  when it was locked.
    LockDate TIMESTAMP (4)
  )
  LOGGING ;
ALTER TABLE Accounts ADD CONSTRAINT USERNAME_PWORD_NOT_SAME CHECK (TRIM(Username)         != TRIM(PWord)) ;
ALTER TABLE Accounts ADD CONSTRAINT PWORD_START_UPPERCASE CHECK (SUBSTR(PWord, 1, 1)       = UPPER(SUBSTR(PWord, 1, 1))) ;
ALTER TABLE Accounts ADD CONSTRAINT USERNAME_START_UPPERCASE CHECK (SUBSTR(Username, 1, 1) = UPPER(SUBSTR(Username, 1, 1))) ;
ALTER TABLE Accounts ADD CONSTRAINT Accounts_PK PRIMARY KEY ( ID ) ;
ALTER TABLE Accounts ADD CONSTRAINT Accounts_Username_UN UNIQUE ( Username ) ;

CREATE TABLE LoginAttempts
  (
    AccountsID    NUMBER (10) NOT NULL ,
    WhenAttempted TIMESTAMP (4) NOT NULL ,
    --  'Y' or 'N'
    WasSuccessful CHAR (1) NOT NULL
  )
  LOGGING ;
ALTER TABLE LoginAttempts ADD CHECK ( WasSuccessful IN ('N', 'Y')) ;
ALTER TABLE LoginAttempts ADD CONSTRAINT LoginAttempts_PK PRIMARY KEY ( WhenAttempted, AccountsID ) ;

CREATE TABLE Sessions
  (
    AccountsID    NUMBER (10) NOT NULL ,
    WhenInitiated TIMESTAMP (4) NOT NULL ,
    --  If NULL, the session is still active. Otherwise, the value is the timestamp
    --  when the session was terminated.
    --  When a new session for a given account is initiated, all other open
    --  sessions for that account are terminated.
    WhenTerminated TIMESTAMP (4)
  )
  LOGGING ;
ALTER TABLE Sessions ADD CONSTRAINT Sessions_PK PRIMARY KEY ( AccountsID, WhenInitiated ) ;


create or replace PROCEDURE Login(UNameEntry IN Accounts.Username%TYPE,
                                  PWordEntry IN Accounts.PWord%TYPE)

IS

  Invalid_User        EXCEPTION;
  Invalid_PWord       EXCEPTION;
  Locked_Out          EXCEPTION;
  Locking_Out         EXCEPTION;

  IDVar               Accounts.ID%TYPE;
  UNameVar            Accounts.Username%TYPE;
  PWordVar            Accounts.PWord%TYPE;
  LockDateVar         Accounts.LockDate%TYPE;
  FailedCountVar      NUMERIC(2) NOT NULL := 0;
  UserCountVar        NUMERIC(2) NOT NULL := 0;
  CurrTimestampVar    TIMESTAMP;

BEGIN
  SELECT LOCALTIMESTAMP INTO CurrTimestampVar FROM DUAL;

  SELECT COUNT(Accounts.ID) INTO UserCountVar FROM Accounts
  WHERE Accounts.Username = UNameEntry;
  
  IF UserCountVar != 1 THEN
    RAISE Invalid_User;
  END IF;
  
  SELECT Accounts.Username INTO UNameVar FROM Accounts
  WHERE Accounts.Username = UNameEntry;
  SELECT Accounts.ID INTO IDVar FROM Accounts
  WHERE Accounts.Username = UNameEntry;
  SELECT Accounts.LockDate INTO LockDateVar FROM Accounts
  WHERE Accounts.Username = UNameEntry;

  IF LockDateVar IS NOT NULL THEN
    INSERT INTO LoginAttempts VALUES (IDVar, CurrTimestampVar, 'N');
    RAISE Locked_Out;
  END IF;

  SELECT Accounts.PWord INTO PWordVar FROM Accounts
  WHERE Accounts.Username = UNameEntry;

  IF PWordEntry != PWordVar THEN

    SELECT COUNT(LoginAttempts.AccountsID) INTO FailedCountVar FROM LoginAttempts
    WHERE LoginAttempts.AccountsID = IDVar
    AND LoginAttempts.WasSuccessful = 'N'
    AND TRUNC(LoginAttempts.WhenAttempted) = TRUNC(CurrTimestampVar)
    AND LoginAttempts.WhenAttempted > (SELECT Accounts.UnLockDate FROM Accounts WHERE Accounts.ID = IDVar);

    INSERT INTO LoginAttempts VALUES (IDVar, CurrTimestampVar, 'N');
    FailedCountVar := FailedCountVar + 1;

    IF FailedCountVar < 3 THEN
      RAISE Invalid_PWord;
    ELSE
      UPDATE Accounts
        SET LockDate = CurrTimestampVar
        WHERE Accounts.ID = IDVar;
      RAISE Locking_Out;
    END IF;
  ELSE
    INSERT INTO LoginAttempts VALUES (IDVar, CurrTimestampVar, 'Y');
  
    UPDATE Sessions
      SET WhenTerminated = CurrTimestampVar
      WHERE Sessions.AccountsID = IDVar
      AND Sessions.WhenTerminated IS NULL;
  
    INSERT INTO Sessions VALUES (IDVar, CurrTimestampVar, NULL);
  END IF;

EXCEPTION
  WHEN Invalid_User THEN
    RAISE_APPLICATION_ERROR(-20001, 'Invalid username.');
  WHEN Locked_Out THEN
    COMMIT;
    RAISE_APPLICATION_ERROR(-20002, 'The account is locked.' || CHR(13) || CHR(10) || 'Please contact administrator for more information.');
  WHEN Invalid_PWord THEN
    COMMIT;
    RAISE_APPLICATION_ERROR (-20003, 'Invalid password.' || CHR(13) || CHR(10) || (3 - FailedCountVar) || ' attempts left before the account will be locked!');
  WHEN Locking_Out THEN
    COMMIT;
    RAISE_APPLICATION_ERROR (-20004, 'Invalid password. The account is now locked!' || CHR(13) || CHR(10) || 'Please contact administrator for more information.');
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR (-20000, 'Unknown Error.');

END Login;
/

ALTER TABLE LoginAttempts ADD CONSTRAINT LoginAttempts_Accounts_FK FOREIGN KEY ( AccountsID ) REFERENCES Accounts ( ID ) NOT DEFERRABLE ;

ALTER TABLE Sessions ADD CONSTRAINT Sessions_Accounts_FK FOREIGN KEY ( AccountsID ) REFERENCES Accounts ( ID ) NOT DEFERRABLE ;

CREATE SEQUENCE Accounts_ID_SEQ START WITH 1 NOCACHE ORDER ;
CREATE OR REPLACE TRIGGER Accounts_ID_TRG BEFORE
  INSERT ON Accounts FOR EACH ROW WHEN (NEW.ID IS NULL) BEGIN :NEW.ID := Accounts_ID_SEQ.NEXTVAL;
END;
/


-- Oracle SQL Developer Data Modeler Summary Report: 
-- 
-- CREATE TABLE                             3
-- CREATE INDEX                             0
-- ALTER TABLE                             10
-- CREATE VIEW                              0
-- CREATE PACKAGE                           0
-- CREATE PACKAGE BODY                      0
-- CREATE PROCEDURE                         1
-- CREATE FUNCTION                          0
-- CREATE TRIGGER                           1
-- ALTER TRIGGER                            0
-- CREATE COLLECTION TYPE                   0
-- CREATE STRUCTURED TYPE                   0
-- CREATE STRUCTURED TYPE BODY              0
-- CREATE CLUSTER                           0
-- CREATE CONTEXT                           0
-- CREATE DATABASE                          0
-- CREATE DIMENSION                         0
-- CREATE DIRECTORY                         0
-- CREATE DISK GROUP                        0
-- CREATE ROLE                              0
-- CREATE ROLLBACK SEGMENT                  0
-- CREATE SEQUENCE                          1
-- CREATE MATERIALIZED VIEW                 0
-- CREATE SYNONYM                           0
-- CREATE TABLESPACE                        0
-- CREATE USER                              0
-- 
-- DROP TABLESPACE                          0
-- DROP DATABASE                            0
-- 
-- REDACTION POLICY                         0
-- 
-- ERRORS                                   0
-- WARNINGS                                 0
